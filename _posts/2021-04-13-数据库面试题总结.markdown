---
title: 数据库面试题总结
author: not_you
date: 2021-04-13 28:51:00 +0800
categories: ["数据库","面试题"]
tags: [数据库]

---



### 事务的基本特性和隔离级别

（1）基本特性ACID如下：

- 原子性（Atomicity）:一个事务中的操作要么全部成功要么全部失败

- 一致性（Consistency）：事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。

- 隔离性（Isolation）：事务提交前对其他事务不可见

- 持久性（Durability）：一旦事务提交，所做的修改就会永久保存到数据库中

（2）四个隔离级别：

- 读未提交（read uncommitted）：可能会读到其它事务未提交的数据，也叫脏读
- 读已提交（read committed）：两次读取结果不一致，不可重复读
- 可重复读（repeatable read）：可重复读，但是可能幻读
- 串行化（serializable）：一般不适用，因为会大量加行锁，代价极大 

### ACID靠什么保证

（1）原子性：由undo log日志保证,它记录了需要回滚的日志信息,事务回滚时撤销已经执行成功的sql
（2）一致性：由其他三大特性保证、程序代码要保证业务上的一致性
（3）隔离性：由MVCC来保证

（4）持久性：由内存+redolog来保证,mysql修改数据同时在内存和redo log记录这次操作,宕机的时候可以从redo Iog恢复

``` InnoDB redo log 写盘 InnoDB事务进入prepare状态
如果前面prepare成功, bin log写盘，再继续将事务持久化到bin log,如果持久化成功,那么InnoDB事务则进入commit状态(在redo log里面写一个commit记录）
```

### MVCC

多版本并发控制:读友数据时通过一种类似快照的方式将数据保存下来,这样读锁就和写锁不冲突了,不同的事务session会看到自己特定版本的数据,版本链

MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作。其他两个隔离级别和MVCC不兼容,因为READ UNCOMMITTED总是读取最新的数据行,而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁

**聚集索引记录中有两个必要的隐藏列:**
trx_id:用来存储每次对某条聚集索引记录进行修改的时候的事务id.

roll_pointer:每次对哪条聚集索引记录有修改的时候,都会把老版本写入undo log中。这个roll_pointer就是存了一个指针,它指向这条聚集索引记录的上一个版本的位置,通过它来获得上一个版本的记录信息。(注意插入操作的undo log没有这个属性,因为它没有老版本)

| id   | name     | trx_id | roll_pointer                         |
| ---- | -------- | ------ | ------------------------------------ |
| 1    | not_you1 | 80     | 上一版本地址，也就是这个表格的下一条 |
| 1    | not_you0 | 50     | 同上                                 |
| 1    | not_you  | 30     |                                      |



**己提交读和可重复读的区别就在于它们生成Readview的策略不同。**

### 锁的类型

基于粒度划分：

- 表锁：锁住整个表，不会产生死锁

- 行锁：只锁住一行或者多行。其他事务可以正常访问别的记录

- 记录锁：行锁的一种，但是记录锁只锁住表的某一项记录，并且命中条件是唯一索引。避免了重复度和脏读

- 间隙锁：行锁的一种，锁住表记录的一个区间，用于防止幻读

### 慢查询处理

- 首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写。

- explain,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引。

- 如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表

### mysql主从同步

mysql生从同步的过程:

**Mysql的主从复制中主要有三个线程:master (binlog dump thread) slave(I/O thread、SQL thread)**，Master一条线程和Slave中的两条线程。

* 主节点binlog,主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库服务器启动的那一刻起,保存所有修改数据库结构或内容的一个文件。

- 主节点log dump线程，当binlog有变动时,log dump线程读取其内容并发送给从节点
- 从节点I/O线程接收binlog内容,并将其写入到relay log文件中。
- 从节点的SQL线程读友relaylog文件内容对数据更新进行复现,最终保证主从数据库的一致性

注:主从节点使用binglog文件+position偏移量来定位主从同步的位置,从节点会保存其已接收到的偏移量（也即增量同步），如果从节点发生宕机重启,则会自动从position的位置发起同步

由于**mysql默认的复制方式是异步的**,主库把日志发送给从库后不关心从库是否已经处理,这样会产生一个问题，假设主库挂了,从库处理失败,这时候从库升为主库后,日志就丢失了,由此产生两个概念

- **全同步复制：**主库写入binlog后强制同步日志到从库,所有的从库都执行完成后才返回给客户端,但是性能会受到严重影响

- **半同步复制：**从库写入日志成功后返回ACK给主库，主库收到至少一个从库的确认就认为写操作完成

### MyISAM和InnoDB的区别

**MyISAM:**

- 不支持事务，但是每次查询都是原子的。且没有data cache，所有DML操作只写到OS cache中，flush disk操作均由OS来完成

- 支持表级锁，即每次操作是对整个表加锁

- 存储表的总行数

- 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件

- 采用非聚集索引,索引文件的数据域存储指向数据文件的指针。辅助引与主索引基本一致,但是辅索引不用保证唯一性。

**InnoDB:**

- 支持ACID的事务，支持事务的四种隔离级别
- 支持行级锁及外键约束，因此可以支持写并发
- 不存储总行数
- 一个InnoDb引擎存储在一个文件空间（共享表空间,表大小不受操作系统控制,一个表可能分布在多个文件里），也有可能为多个(设置为独立表空间,表大小受操作系统文件大小限制,一舫为2GB),受操作系统文件大小的限制;

- 主键索引采用聚集索引，辅助索引的数据域存储主键值。因此从辅索引查找数据,需要回表;最好使用自增主键,防止插入数据时,为维持B+树结构,文件的大调整。

### 待续





