---
title: 五月份刷题记录
author: not_you
date: 2021-04-27 00:03:00 +0800
categories: ["leetcode"]
tags: ["刷题"]

---

### git链接

[我的leetcode刷题记录](https://github.com/hubing1791/my_leetcode)

### 958.二叉树的完全性检验

[题目链接](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

（1）直接的思路是。利用层序遍历，并对节点编号，子节点编号为父节点的两倍或者两倍加一（对应左右节点），遍历结束后看是否是不断数字的单增序列即可，最后的判断不用遍历，因为是主动编的号，只要看最后一个数等于长度与否即可。

(2)一看答案思路一样的，答案写法更简洁。不过没什么差



### 92.反转链表2

[题目链接](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

（1）总共需要找到4个节点，left的前节点，left，right的后节点，right，但是存在前后节点不存在的情况。

（2）对于1中的情况，left无前节点添加一个新的头即可使得统一处理方式，而right后节点不存在不影响处理

（3）一开始没看错题了，left和right指位置，当成val值了

（4）第二版写了一个一次遍历版



### 470,用 Rand7() 实现 Rand10()

[题目链接](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

（1）经典实现方式，先转化成一个均匀的49上的分布，对于多出来的再调用子集一次即可，连续不中的概率会持续降低

（2）题解给了继续利用被拒绝的数的算法，但是代码反而便繁琐了，效率没有明显提升



### 剑指offer36.二叉搜索树和双向链表

[题目链接](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

（1）看题目描述，上来的思路是基于中序遍历改。首先想到了一个很简单暴力的方式，直接把中序遍历结果放在列表里，再连。对于只有一个结点的二叉搜索树一开始没兼顾到。

（2）看了题解，别人使用了递归，我使用的是迭代。



### 98.验证二叉搜索树

[题目链接](https://leetcode-cn.com/problems/validate-binary-search-tree/)

（1）直接中序遍历，使用迭代，在遍历的过程中就进行检验

（2）犯了个低级错误，while里的条件应该是stack or node，整半天没注意到，一直在疑惑

（2）二叉搜索树不允许有相同的值，一开始漏考虑了这个条件



### 148.排序链表

[题目链接](https://leetcode-cn.com/problems/sort-list/solution/)

（1）归并排序的应用，有自顶向下和自下至上，后者可以做到空间复杂度o（1）。后者其实也就是不递归的做法。

（2）参考了一下官方的题解，对于如何写递归式卡住了一下

（3）在把一个链表切开的过程中，使用快慢链表，会遇到一个问题。比如，[1,2,3,4,5,6],使用快慢链表切，例如慢指向3快指向6，这时候要么选择切断成两个链表，那得补充一个3->next=NULL，如果不补充，意味着切割后的实际上是[1,2,3],[3,4,5,6],3被重复指向了。而[解答链接]()里，使用了如图的方式，解决了这个问题。但是可读性挺差的。

![截图]({{site.url}}/assets/img/2021_04_27/1.png)

（4）基于一般的归并排序写了和官方题解不同的版本，通过锻炼避免（3）中的情况，比官方解答可读性更强

（5）在merge（）中连接两个链表时，链表1，链表2中同样val的节点，2中的会排在后面，因此需要在找head2尾巴时，在等于时页更新tail

![截图]({{site.url}}/assets/img/2021_04_27/2.png)



### 200.岛屿数量

[题目链接](https://leetcode-cn.com/problems/number-of-islands/)

（1）初始想法是将岛生成一个点的集合，然后组成一个列表，最后数列表。在具体实现过程中发现这个想法需要大量特殊情况。换了思路改为沉岛法。

（2）在一个令人无语的地方看了半天，题目给的0，1是字符串不是数字。

（3）题解有并查集法，值得看一下



### 补充题：圆环上回到原点：

[题目链接](https://mp.weixin.qq.com/s/VnGFEWHeD3nh1n9JSDkVUg)

**题目描述**：圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。

（1）动态规划问题，和爬楼梯的区别就是需要对环的点数取余数



### 198.打家劫舍

[题目链接](https://leetcode-cn.com/problems/house-robber/)

（1）大概思考了下，可以对数组扫描，然后动态规划。当前位置偷到的最多的钱为当前位置值加上前面隔一个位置的偷到的最多的钱和前一位位置偷到最多钱中比较大的那个



### 93.复原ip地址

[题目链接](https://leetcode-cn.com/problems/restore-ip-addresses/)

（1）思路很直接，但是在具体写的过程中如何清晰的写参考了答案。答案写的比较清爽。



### 24.两两交换链表中的节点

[题目链接](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

（1）k个一组翻转链表的弱化版。



### 41.缺失的第一个正数

[题目链接](https://leetcode-cn.com/problems/first-missing-positive/)

（1）上来就想到的是利用快排，然后在已经排好的部分继续搜索，但是想到了一个问题，例如第一次排，将数组分为左右两个部分，那想要确定左边缺少那个，还是得把左边都排序了

（2）想到用字典，思考了下不符合题目要求

（3）直接看答案了



### 300.最长递增子序列

[题目链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

（1）o（n^2）复杂度的很容易实现。对每一个数都向后扫描即可

（2）对于（1）的思路，可以通过记录最小值减少遍历次数。比如对于i位置的数K，如果i位置之前已经有一个数M小于K，那么从K起找的数必少于从M起的，因此对于K没必要向后搜索了

（3）写到一半发现一个问题，对于[3,8,5,6,7]这样的序列，从3开始搜索，得跳过8，但是怎么确定要不要跳过呢。所以之前的思路有问题，从左向右扫描不可行，应该得是动态规划。

（4）题目的进阶要求有点难，看题解写的了。贪心加二分查找



### 234.回文链表

[题目链接](https://leetcode-cn.com/problems/palindrome-linked-list/)

(1)快慢链表找中点，然后反转比较。



### 739.每日温度

[题目链接](https://leetcode-cn.com/problems/daily-temperatures/)

（1）上来就想到了o（n^2）的写法，但是答案应该不会允许这么蠢的实现。

（2）官方第一种暴力解答通过从后向前遍历减小了复杂度

（3）第二种解答，单调栈



### 114.展开二叉树为链表

[题目链接](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

（1）先遍历再组合很简单，略过。

（2）在迭代时对节点重连，见题解



### 240.搜索二维矩阵II

[题目链接](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

（1）这类题应该都是选择右上角或者左下角，从而使得某一方向必然是变大变小方便搜索



### 面试金典0305

[题目链接](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)

（1）想了下，不就是个单调栈问题。只不过额外加一个栈暂时存储。

（2）用python实现有点尴尬，现成的操作都有了。不过考核点应该就是两个栈来回倒腾实现单调栈



### 556.下一个更大元素III

[题目链接](https://leetcode-cn.com/problems/next-greater-element-iii/)

（1）对于一个数字串，通过移动元素使其变大，应当是使用后面的某个数a，a尽可能靠右，替换前面的某个数b，b需要小于a且尽可能靠右，替换后右侧的数要按照升序排列。

（2）问题转化为了，寻找尽可能靠右的某位数a，与尽可能靠右的b交换，此时可以利用该题的II版的算法

（3）并且注意，以178954为例，最后得到的数为179458，9交换后，后面的数直接逆序排列。因为在找到目标的b之前，必然先经过一段序列是从右向左增加的

（4）写的过程中想到了，大可不必，从后往前找，发现降序即可，发现降序即可交换，交换后把后面逆转。具体看代码注释



### 字节补充_2021_05_27

题目内容：数组先递增后递减，求数组内不重复的数

（1）从两端开始扫描即可



### 80.删除有序数组中重复项2

[题目链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

（1）想到了一个很简单的思路，就是类似滑动窗口比较，保持着三个数，如果都相等就删除，删到只有两个相等为止，向后继续滑动。写的时候又思考了一下，没有必要。使用两个数一个记录重复次数一个记录

（2）答案的双指针法很有意思，但是和我的方法比的话，我的方法可以任意调整需要保留的个数，只需修改一个值而函数流程完全不用变。不过如果把题目理解为不可以删除作为参数传入的列表的数，那双指针就是唯一的了



### 718.最长重复子数组

[题目链接](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

（1）有个笨办法，先排序，然后双指针找即可。

（2）（1）是错的，仔细读了下题目要求，配合题解，题目的意思应该是不可以打乱顺序和选取部分。这样的话想到的就是滑动窗口了。还是参考答案。

（3）动态规划，滑动窗口，hash加二分查找三种方法。方法三没看，太难了。



### 287.寻找重复的数

[题目链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)

（1）先排序后找，复杂度比较高。必然可行。但是这道题应该不可能考核的是排序算法的实现。更具抽屉原理，必然有一个1-n之间重复的数。想到了之前做题时使用的标记的方法。就是缺失的第一个正数里的。可以扫描数值a，然后标记a-1位置上的值，标记为负数。被重复标记的位置会变为正数。之后2次扫描即可。

（2）（1）不对，（1）只能解决抽屉原理问题。这题重复的数可能重复很多遍。因此对（1）做了修改，思路是。如果有重复的，那某个下标必然会先被改为小于零然后再次被访问，再次访问时返回这个下标即可。这个方法优于官方题解的最优解。



### 647.回文子串

[题目链接](https://leetcode-cn.com/problems/palindromic-substrings/)

(1)这题必然是动态规划题，从题目条件说不同位置的相同串算就说明了这一点了。应该可以通过二维动态规划实现。最后数矩阵里的结果的个数