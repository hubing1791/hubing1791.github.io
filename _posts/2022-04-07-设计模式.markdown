---
title: 设计模式
author: not_you
date: 2022-04-07 00:00:00 +0800
categories: ["系统学习"]
tags: [设计模式]
---



### git链接

[我的设计模式学习记录，包含代码和的注释](https://github.com/hubing1791/my_leetcode)

面试被问到设计模式被问住了，痛定思痛。系统的彻底学一下

TvT，小吐槽，还是逃不掉java啊

### 单例设计模式：

定义：保证一个类只有一个实例，并提供一个全局访问点

场景：重量级对象，不需要多个实例，如线程池，数据库连接池

具体实现：

#### 懒汉模式：

延迟加载，只有在真正使用的时候，才开始实例化。

1）线程安全问题

2）double check 加锁优化

3）编译器（JIT），CPU有可能对指令进行重排序，导致使用到尚未初始化额实例，可以通过添加volatile关键字进行修饰，对于volatile修饰的字段，可以防止指令重排。

#### 饿汉模式：

类加载的初始化阶段就完成了实例的初始化。本质上就是借助于jvm类加载机制，保证实例的唯一性。

类加载过程：

1.加载二进制数据到内存中，生成对应的Class数据结构

2.连接：a.验证，b.准备（给类的静态成员赋默认值），c.解析

3.初始化：给类的静态变量赋初值

只有在真正使用对应的类时，才会触发初始化。

#### 静态内部类：

1.本质上时利用类的加载机制来保证线程安全

2.只有在实际使用的时候，才会触发类的初始化，所以也是一种懒加载

#### enum：

1.还是借用了jvm的机制，可以抵抗反射，并且也是线程安全的

相关问题：

- 反射攻击：静态内部类和饿汉模式可以通过在构造器里加判断防御，但是懒汉模式不行
- 反序列化攻击：object readReslove() throws ObjectStreamException 可解，需要定义版本号



### 工厂模式

定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。

场景：需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。当你不知道使用对象的确切类型；当你希望为库或框架提供拓展其内部组件的方法时

#### 简单工厂：

在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。**简单工厂模式不在 GoF 23 种设计模式之列。**

1.单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，**违背了“开闭原则”**。

#### 工厂方法模式：

工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。每个具体工厂有对应的具体产品

1.优点：

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。

- 灵活性比简单工厂强，对于新产品的创建，只需多写一个相应的工厂类。
- 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

2.缺点：

- 类的个数容易过多，增加复杂度
- 增加了系统的抽象性和理解难度
- 抽象产品只能生产一种产品

#### 抽象工厂：

是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

1.应用场景：

- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品
- 系统一次只可能消费其中某一族产品，即同族的产品一起使用

2.优点：

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
- 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

3.缺点：

- 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。



### 建造者模式

定义:

- 将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的

应用场景：

- 相同的方法，不同的执行顺序，产生不同的结果。
- 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
- 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
- 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。

#### 建造者模式

1.建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成

- 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
- 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
- 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
- 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

2.优点：

- 封装性好，构建和表示分离。
- 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
- 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。

3.缺点：

- 产品的组成部分必须相同，这限制了其使用范围。
- 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。



### 原型模式

定义：

用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。

应用场景：

- 对象之间相同或相似，即只是个别的几个属性不同的时候。
- 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
- 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。

#### 浅拷贝

Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。

- 为了实现独立性，假如原型里有引用，那可能需要进行额外的修改。即需要深拷贝

#### 深拷贝

创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。可以借助序列化实现



### 代理模式

定义：

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

应用场景：

- 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间
- 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
- 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
- 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
- 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。

1.优点：

- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
- 代理对象可以扩展目标对象的功能；
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

2.缺点：

- 代理模式会造成系统设计中类的数量增加
- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
- 增加了系统的复杂度；

#### 静态代理

由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。

静态代理只能通过手动完成代理操作，如果被代理类增加了新的方法，则代理类需要同步增加，**违背开闭原则**。

#### 动态代理

在程序运行时，运用反射机制动态创建而成。解决了真实主题与代理主题一一对应，增加真实主题也要增加代理。
设计代理以前真实主题必须事先存在，不太灵活。这两个问题

1.特点：

- 代理对象不需要实现接口
- 代理对象的生成是利用 JDK 的 API 动态的在内存中构建代理对象
- 能在代码运行时动态地改变某个对象的代理，并且能为代理对象动态地增加方法、增加行为

2.实现：

使用 newProxyInstance 方法，该方法需要接收三个参数，语法格式如下：

```java
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h );
// ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的
// Class<?>[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型
// InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，把当前执行目标对象的方法作为参数传入
```



### 适配器模式

定义：

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

应用场景：

- 你想使用一个已经存在的类，而它的接口不符合你的需求
- 你想创建一个可以复用的类，该类可以与其它不相关的类或者不可预见的类（即那些接口可能不一定兼容的类）
- （仅适用于对象adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器何以适配它们的父类

结构：

1.目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
2.适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
3.适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

#### 类适配器

类适配器的权衡如下

- 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想要匹配一个类以及其它所有它的子类是，类Adapter将不能工作
- 使得Adapter可以重定义Adaptee的部分行为,因为Adapter是Adaptee的一个子类
- 仅仅引入了一个对象，不需要额外的指针以间接得到Adaptee

#### 对象适配器

对象适配器的权衡：

- 允许一个adapter与多个Adaptee——Adaptee本身以及它的所有子类（如果有子类的话）——同时工作。Adapter也可以一次给所有的Adaptee添加功能。
- 使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。

#### 双向适配器

不算是一种适配器模式，但是是一个学习点



### 桥接模式

定义：抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

应用场景：

- 不希望抽象和具体实现之间有一个固定的绑定关系
- 类的抽象以及它的实现都可以通过生成子类的方式加以扩充。bridge模式使得可以对不同的抽象接口和和实现部分进行组合，并分别对他们进行扩充。
- 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译
- 有许多类需要生成
- 想在多个用户间共享实现（可能使用引用计数），但同时要求客户不知道这点。

#### 实现

桥接（Bridge）模式包含以下主要角色。

- 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
- 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
- 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
- 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。



### 装饰器模式

定义：

指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

优点：

装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
装饰器模式完全遵守开闭原则

缺点：

装饰器模式会增加许多子类，过度使用会增加程序得复杂性。  

结构：

- 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
- 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
- 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
- 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。    



### 外观模式

定义：

又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

是“迪米特法则”的典型应用。

优点：

- 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
- 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
- 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

缺点：

- 不能很好地限制客户使用子系统类，很容易带来未知风险。
- 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

实现：

- 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
- 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
- 客户（Client）角色：通过一个外观角色访问各个子系统的功能。



### 参考

[Java设计模式：23种设计模式全面解析（超级详细）](http://c.biancheng.net/design_pattern/)

[设计模式：可复用面向对象软件的基础](https://book.douban.com/subject/34262305/)



### 残留问题

一些额外的还没看的问题：